# Feature: Multi-Repository Orchestration

## Summary

Extend GitClaw's awareness beyond a single repository. The agent discovers related repos in the same GitHub organization, cross-references code and issues, coordinates changes that span multiple repos, and maintains an org-level view of project health. When a change in Repo A breaks Repo B's API contract, the agent in Repo A can open an issue in Repo B alerting the team. When a shared library is updated, the agent can propose dependency bumps across all consuming repos. The agent evolves from a single-repo assistant to an organization-aware collaborator that understands the dependency graph between projects.

## Why This Feature ‚Äî The Deep Reasoning

### 1. No Real Project Lives in a Single Repository

Modern software is distributed across repos: the API in one, the frontend in another, shared libraries in a third, infrastructure in a fourth. Changes in one repo cascade to others. A breaking API change requires frontend updates. A library vulnerability requires bumps in every consumer. A schema migration requires coordinated deployment.

Today, GitClaw is blind to everything outside its own repo. It can't know that the function it's refactoring is also called by three other repos. It can't warn that the type it's changing is exported and consumed downstream. Multi-repo awareness fills this gap.

### 2. GitHub's Organization API Makes This Possible

GitHub's API provides:
- `GET /orgs/{org}/repos` ‚Äî list all repos in the org
- `GET /repos/{owner}/{repo}/contents/{path}` ‚Äî read files from other repos
- `POST /repos/{owner}/{repo}/issues` ‚Äî create issues in other repos
- `POST /repos/{owner}/{repo}/dispatches` ‚Äî trigger workflows in other repos (event bridge, feature 13)

The `GITHUB_TOKEN` generated by GitHub Actions has access to repos within the same org (configurable via token permissions). No additional authentication is needed.

### 3. Cross-Repo Dependency Awareness Prevents Breaking Changes

When the agent in `org/api-service` modifies an exported type, it should check if `org/frontend`, `org/mobile-app`, or `org/sdk` import that type. If they do, the agent should:
1. Warn the user that the change has downstream consumers
2. Open issues in the consuming repos alerting their maintainers
3. Optionally propose compatibility shims or migration guides

This is the multi-repo equivalent of "run the tests" ‚Äî but across organizational boundaries.

### 4. It Composes as the Coordination Layer

| Feature | Multi-Repo Dimension |
|---|---|
| **Health Scanning (19)** | Org-wide health dashboard, cross-repo dependency staleness |
| **Event Bridge (13)** | `repository_dispatch` to trigger actions in other repos |
| **Release Management (23)** | Coordinate releases across related repos |
| **Knowledge Base (17)** | Org-level knowledge base shared across repos |
| **Notification Intelligence (20)** | Cross-repo escalation chains |
| **Dashboard (14)** | Org-level dashboard aggregating all repos |

### 5. The GITHUB_TOKEN Scope Enables This Without New Secrets

GitHub Actions `GITHUB_TOKEN` can be configured with permissions to access other repos in the same org (via `permissions:` in workflow YAML or organization settings). For private repos within an org, the token needs `repo` scope on the target repos. For public repos, read access is already available. The workflow just needs `actions: write` and `contents: read` on the target repos.

## Scope

### In Scope
- **Repo discovery**: List and categorize repos in the org
- **Dependency graph**: Build a dependency graph from package manifests across repos
- **Cross-repo search**: Search for symbol/type usage across repos
- **Cross-repo alerting**: Open issues in other repos when changes affect them
- **Dependency bump proposals**: When a shared library updates, propose bumps in consumers
- **Org-level health**: Aggregate health scan results across repos
- **Configuration**: Define repo relationships in `.GITCLAW/repos.json`

### Out of Scope
- Cross-org awareness (different GitHub organizations)
- Monorepo support (that's a different problem ‚Äî multiple packages in one repo)
- Automated cross-repo code changes (too dangerous ‚Äî only alerts and proposals)
- Cross-repo session sharing (sessions stay in their repo)

## Effort Estimation

| Component | Changes | Effort |
|---|---|---|
| **Repo discovery** | Org API integration, repo metadata caching | ~1.5 hours |
| **Dependency graph builder** | Parse manifests across repos, build graph | ~2.5 hours |
| **Cross-repo search** | Search for symbols across related repos | ~2 hours |
| **Cross-repo alerting** | Create issues in other repos via API | ~1.5 hours |
| **Dependency bump proposals** | Detect version changes, propose bumps | ~2 hours |
| **Org-level health aggregator** | Collect and summarize cross-repo health | ~1.5 hours |
| **Configuration** (`repos.json`) | Repo relationships, permissions | ~30 min |
| **Agent orchestrator integration** | Cross-repo checks in pre-commit pipeline | ~1 hour |
| **Docs** | Document multi-repo system | ~30 min |
| **Testing** | Test discovery, graph building, alerting | ~1.5 hours |

**Total: ~15 hours.**

---

## AI Implementation Instructions

### Step 1: Repository discovery

**New file:** `.GITCLAW/lifecycle/GITCLAW-REPOS.ts`

```typescript
export interface RepoInfo {
  name: string;
  fullName: string;           // "org/repo"
  description: string;
  language: string;
  defaultBranch: string;
  isPrivate: boolean;
  hasGitclaw: boolean;        // whether .GITCLAW/ exists
  updatedAt: string;
  dependencies: string[];     // repos this repo depends on (from manifest)
  dependents: string[];       // repos that depend on this repo
}

export interface OrgGraph {
  org: string;
  repos: RepoInfo[];
  edges: { from: string; to: string; type: "depends-on" | "imports" | "references" }[];
  lastUpdated: string;
}

export async function discoverRepos(org: string): Promise<RepoInfo[]> {
  const { stdout } = await run([
    "gh", "api", `orgs/${org}/repos`,
    "--paginate",
    "--jq", `.[] | {name, fullName: .full_name, description: (.description // ""), language: (.language // ""), defaultBranch: .default_branch, isPrivate: .private, updatedAt: .updated_at}`,
  ]);
  
  const repos: RepoInfo[] = [];
  
  for (const line of stdout.trim().split("\n").filter(Boolean)) {
    try {
      const repo = JSON.parse(line);
      
      // Check if repo has GitClaw installed
      try {
        await run(["gh", "api", `repos/${repo.fullName}/contents/.GITCLAW`, "--jq", ".name"]);
        repo.hasGitclaw = true;
      } catch (e) {
        repo.hasGitclaw = false;
      }
      
      repo.dependencies = [];
      repo.dependents = [];
      
      repos.push(repo);
    } catch (e) { /* skip */ }
  }
  
  return repos;
}
```

### Step 2: Dependency graph builder

```typescript
export async function buildDependencyGraph(
  repos: RepoInfo[],
  org: string
): Promise<OrgGraph> {
  const edges: OrgGraph["edges"] = [];
  
  for (const repo of repos) {
    // Check package.json for npm dependencies
    try {
      const { stdout: pkgJson } = await run([
        "gh", "api", `repos/${repo.fullName}/contents/package.json`,
        "--jq", ".content",
      ]);
      
      const decoded = Buffer.from(pkgJson.trim(), "base64").toString("utf-8");
      const pkg = JSON.parse(decoded);
      const allDeps = {
        ...pkg.dependencies,
        ...pkg.devDependencies,
      };
      
      // Check if any dependencies point to other org repos
      for (const [depName, depVersion] of Object.entries(allDeps as Record<string, string>)) {
        // GitHub dependency format: "org/repo" or "github:org/repo"
        if (depVersion.includes(`${org}/`) || depVersion.includes(`github:${org}/`)) {
          const targetRepo = depVersion.match(new RegExp(`${org}/([^#@]+)`))?.[1];
          if (targetRepo) {
            edges.push({ from: repo.fullName, to: `${org}/${targetRepo}`, type: "depends-on" });
            repo.dependencies.push(`${org}/${targetRepo}`);
            
            const target = repos.find(r => r.name === targetRepo);
            if (target) target.dependents.push(repo.fullName);
          }
        }
        
        // Also check for scoped packages that match org repos
        // e.g., @org/package-name might correspond to org/package-name
        if (depName.startsWith(`@${org}/`)) {
          const repoName = depName.replace(`@${org}/`, "");
          const target = repos.find(r => r.name === repoName);
          if (target) {
            edges.push({ from: repo.fullName, to: target.fullName, type: "depends-on" });
            repo.dependencies.push(target.fullName);
            target.dependents.push(repo.fullName);
          }
        }
      }
    } catch (e) {
      // No package.json or can't read it ‚Äî skip
    }
    
    // Check go.mod for Go dependencies
    try {
      const { stdout: goMod } = await run([
        "gh", "api", `repos/${repo.fullName}/contents/go.mod`,
        "--jq", ".content",
      ]);
      const decoded = Buffer.from(goMod.trim(), "base64").toString("utf-8");
      const githubDeps = [...decoded.matchAll(/github\.com\/([^/]+\/[^\s@]+)/g)];
      
      for (const match of githubDeps) {
        const depFullName = match[1];
        if (depFullName.startsWith(`${org}/`)) {
          edges.push({ from: repo.fullName, to: depFullName, type: "depends-on" });
        }
      }
    } catch (e) { /* skip */ }
    
    // Similarly for Cargo.toml, pyproject.toml, etc.
  }
  
  return {
    org,
    repos,
    edges,
    lastUpdated: new Date().toISOString(),
  };
}
```

### Step 3: Cross-repo impact analysis

Run this after the agent makes changes but before committing:

```typescript
export interface CrossRepoImpact {
  affectedRepo: string;
  reason: string;
  severity: "info" | "warning" | "breaking";
  details: string;
}

export async function analyzeCrossRepoImpact(
  changedFiles: string[],
  currentRepo: string,
  graph: OrgGraph
): Promise<CrossRepoImpact[]> {
  const impacts: CrossRepoImpact[] = [];
  
  // Find repos that depend on this one
  const dependents = graph.edges
    .filter(e => e.to === currentRepo)
    .map(e => e.from);
  
  if (dependents.length === 0) return impacts;
  
  // Check if changed files include exported interfaces
  for (const file of changedFiles) {
    // If a package.json was changed (version bump, dependency change)
    if (file === "package.json") {
      for (const dep of dependents) {
        impacts.push({
          affectedRepo: dep,
          reason: "Dependency manifest changed",
          severity: "warning",
          details: `${dep} depends on ${currentRepo}. The package.json was modified ‚Äî check for version compatibility.`,
        });
      }
    }
    
    // If exported types/interfaces were changed
    if (file.match(/\.(ts|js|d\.ts)$/) && (file.includes("index") || file.includes("types") || file.includes("api"))) {
      // Check if the file contains exports
      try {
        const content = readFileSync(file, "utf-8");
        if (/export\s+(interface|type|class|function|const|enum)/m.test(content)) {
          for (const dep of dependents) {
            impacts.push({
              affectedRepo: dep,
              reason: "Exported API surface changed",
              severity: "warning",
              details: `${file} contains exports consumed by ${dep}. Verify compatibility.`,
            });
          }
        }
      } catch (e) { /* skip */ }
    }
  }
  
  return impacts;
}
```

### Step 4: Cross-repo alerting

```typescript
export async function alertAffectedRepos(
  impacts: CrossRepoImpact[],
  sourceRepo: string,
  sourceIssue: number
): Promise<void> {
  // Group impacts by repo
  const byRepo = new Map<string, CrossRepoImpact[]>();
  for (const impact of impacts) {
    const list = byRepo.get(impact.affectedRepo) || [];
    list.push(impact);
    byRepo.set(impact.affectedRepo, list);
  }
  
  for (const [targetRepo, repoImpacts] of byRepo) {
    const maxSeverity = repoImpacts.some(i => i.severity === "breaking") ? "breaking"
      : repoImpacts.some(i => i.severity === "warning") ? "warning" : "info";
    
    const icon = { breaking: "üî¥", warning: "üü°", info: "üîµ" }[maxSeverity];
    
    const body = [
      `## ${icon} Cross-Repo Impact Alert`,
      "",
      `Changes in **${sourceRepo}** (issue ${sourceRepo}#${sourceIssue}) may affect this repository.`,
      "",
      "### Impact Details",
      ...repoImpacts.map(i => `- **${i.severity}**: ${i.reason} ‚Äî ${i.details}`),
      "",
      "### Recommended Action",
      maxSeverity === "breaking"
        ? "‚ö†Ô∏è This may be a breaking change. Review your code for compatibility."
        : "Review the upstream changes and verify no regressions.",
      "",
      `_Source: ${sourceRepo}#${sourceIssue} ¬∑ Automated by GitClaw_`,
    ].join("\n");
    
    try {
      await run([
        "gh", "issue", "create",
        "--repo", targetRepo,
        "--title", `${icon} Impact alert from ${sourceRepo}`,
        "--body", body,
        "--label", "gitclaw:cross-repo-alert",
      ]);
      console.log(`Alert created in ${targetRepo}`);
    } catch (e) {
      console.error(`Failed to create alert in ${targetRepo}: ${e}`);
    }
  }
}
```

### Step 5: Org graph caching

```typescript
// Cache the graph to avoid API calls on every run
export function cacheOrgGraph(stateDir: string, graph: OrgGraph): void {
  writeFileSync(
    resolve(stateDir, "org-graph.json"),
    JSON.stringify(graph, null, 2) + "\n"
  );
}

export function loadCachedOrgGraph(stateDir: string, maxAgeHours: number = 24): OrgGraph | null {
  const cachePath = resolve(stateDir, "org-graph.json");
  if (!existsSync(cachePath)) return null;
  
  const graph: OrgGraph = JSON.parse(readFileSync(cachePath, "utf-8"));
  const age = (Date.now() - new Date(graph.lastUpdated).getTime()) / (1000 * 60 * 60);
  
  if (age > maxAgeHours) return null;
  return graph;
}
```

### Step 6: Configuration

**New file:** `.GITCLAW/repos.json`

```json
{
  "enabled": true,
  "org": "japer-technology",
  "relatedRepos": [],
  "autoDiscover": true,
  "alertOnImpact": true,
  "graphRefreshHours": 24,
  "skipRepos": ["archived-repo", "internal-tools"],
  "crossRepoIssueLabel": "gitclaw:cross-repo-alert"
}
```

### Step 7: Agent orchestrator integration

In `GITCLAW-AGENT.ts`, after the agent runs and before commit:

```typescript
// Cross-repo impact analysis
const reposConfig = loadReposConfig(gitclawDir);
if (reposConfig.enabled && codeChanges.length > 0) {
  let graph = loadCachedOrgGraph(stateDir);
  if (!graph) {
    const repos = await discoverRepos(reposConfig.org);
    graph = await buildDependencyGraph(repos, reposConfig.org);
    cacheOrgGraph(stateDir, graph);
  }
  
  const impacts = await analyzeCrossRepoImpact(codeChanges, repo, graph);
  if (impacts.length > 0 && reposConfig.alertOnImpact) {
    await alertAffectedRepos(impacts, repo, issueNumber);
    // Include impact info in the agent's response
    agentText += `\n\n---\n‚ö†Ô∏è **Cross-repo impact detected**: ${impacts.length} downstream repo(s) may be affected. Alerts have been opened.`;
  }
}
```

### Step 8: Test

- Set up two repos in the same org where Repo A depends on Repo B
- Modify an exported type in Repo B ‚Üí verify an alert issue is created in Repo A
- Verify the org graph is cached and refreshed after 24 hours
- Verify the graph correctly identifies dependency edges from package.json
- Verify repos without GitClaw are still discovered (for dependency tracking)
- Test with no org access ‚Üí verify graceful degradation (feature disabled, not errored)

## Design Decisions

**Why alerts (issues) instead of automated cross-repo code changes?** Cross-repo code changes are extremely dangerous ‚Äî the agent in Repo A doesn't have the full context of Repo B. An incorrect change could break Repo B's tests, introduce regressions, or conflict with in-flight work. Alerts give the Repo B team visibility and let them decide how to respond. If Repo B also has GitClaw, its agent can process the alert.

**Why cache the org graph?** Building the dependency graph requires API calls to every repo (to read their manifests). For an org with 50 repos, that's 50+ API calls. Caching with a 24-hour TTL keeps the graph fresh enough for impact analysis while staying well within API rate limits.

**Why use the GITHUB_TOKEN instead of a separate PAT?** Simplicity. The GITHUB_TOKEN generated by GitHub Actions already has configurable permissions. For public repos, it can read other repos' contents. For private repos within the same org, it can be granted cross-repo access via organization settings. No additional secret management needed.

**Why start with dependency graph analysis instead of full cross-repo code search?** The dependency graph from package manifests is structured, reliable, and fast to build. Full code search (grep every repo for symbol usage) is expensive, noisy, and slow. The graph tells you *which* repos to worry about; focused analysis on those repos tells you *what* to worry about. Start structured, add search later.
